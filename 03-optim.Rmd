# 常见的优化算法 {#optim}

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, tidy = TRUE,
                      warning = FALSE, message = FALSE, comment=NA)
library(tidyverse) # Wickham的数据整理的整套工具
pdf.options(height=10/2.54, width=10/2.54, family="GB1") # 注意：此设置要放在最后
```
## 介绍 {#optim-intro}



## 牛顿优化算法

假设函数 $f(x)$ 可导并一阶导 $f^{\prime}(x)$ 连续，那么最大化 $f(x)$ 相当于求 $f^{\prime}(x) = 0$ 的根，我们就可以使用牛顿法求根。优化 $f(x)$ 就转化成了方程求根问题。 牛顿优化算法的迭代过程如下。

\centering
```{block, type='method'}
**牛顿优化算法**


1. 选择初始猜测点 $x_0$，设置 $n = 0$。
2. 按照以下迭代过程进行迭代：
\begin{equation}
x_{n+1}=x_{n}-\frac{f^{\prime}\left(x_{n}\right)}{f^{\prime\prime}\left(x_{n}\right)}.
\end{equation}
3. 计算 $|f^{\prime}(x_{n+1})|$。
    1. 如果 $|f^{\prime}(x_{n+1})| \leq \epsilon$，停止迭代；
    2. 否则，返回第 2 步。
```

上述优化过程的停止条件还可以为：


- $|x_{n} - x_{n-1}| < \epsilon$.

- $|f(x_{n}) - f(x_{n-1})| < \epsilon$.


```{example}
求 $f(x_1, x_2) = x_1^2 - x_1x_2 + x_2^2 + \exp(x_2)$ 的最小值。

```{r newton}
newton <- function(f, x0, tol = 1e-9, max.iter = 100) {
  x <- x0
  cat(paste0('初始值：','x1 = ',x[1],', x2 = ',x[2],'\n'))
  fx <- ftn(f, x)
  iter <- 0
  # xs用来保存每步迭代得到的x值
  xs <- list()
  xs[[1]] <- x
  # 继续迭代直到满足停止条件
  while((max(abs(fx$fgrad)) > tol) & (iter < max.iter)){
    x <- x - solve(fx$fhess, fx$fgrad)
    fx <- ftn(f, x)
    iter <- iter + 1
    xs[[iter + 1]] <- x
    cat(paste0('迭代第',iter,'次：x1 = ',x[1],', x2 = ',x[2],'\n'))
  }
  if (max(abs(fx$fgrad)) > tol){
    cat('算法无法收敛 \n')
  } else{
    cat('算法收敛\n')
    return(xs)
  }
}

ftn <- function(f, x){
  df <- deriv(body(f), c('x1', 'x2'), func = TRUE, hessian = TRUE)
  dfx <- df(x[1], x[2])
  f <- dfx[1]
  fgrad <- attr(dfx, 'gradient')[1,]
  fhess <- attr(dfx, 'hessian')[1,,]
  return(list(f = f, fgrad = fgrad, fhess = fhess))
}
f <- function(x1, x2) x1^2 - x1 * x2 + x2^2 + exp(x2)
```

```{r, echo=FALSE}
m <- as.data.frame(do.call(rbind, newton(f, c(5, 5))))
nx <- ny <- 100
xg <- seq(-5, 5, len = nx)
yg <- seq(-5, 5, len = ny)
g <- expand.grid(xg, yg)
z <- f(g[,1], g[,2])
f_long <- data.frame(x = g[,1], y = g[,2], z = z)
library(ggplot2)
ggplot(f_long, aes(x, y, z = z)) + 
  geom_contour_filled(aes(fill = stat(level)), bins = 50) + 
  guides(fill = FALSE) +
  geom_path(data = m, aes(x1, x2, z=0), col = 2, arrow = arrow()) +
  geom_point(data = m, aes(x1, x2, z=0), size = 3, col = 2) +
  xlab(expression(x[1])) +
  ylab(expression(x[2])) +
  ggtitle(parse(text = paste0('"牛顿优化算法： "', ' ~ f(x[1],x[2]) == ~ x[1]^2 - x[1] * x[2] + x[2]^2 + exp(x[2])'))) +
  theme(text = element_text(family = "STHeiti"))

```
```
