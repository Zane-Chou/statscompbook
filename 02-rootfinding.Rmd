---
output:
  pdf_document: default
  html_document: default
---
# 求根算法 {#rootfinding}

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, tidy = TRUE,
                      warning = FALSE, message = FALSE, comment=NA)
library(tidyverse) # Wickham的数据整理的整套工具
pdf.options(height=10/2.54, width=10/2.54, family="GB1") # 注意：此设置要放在最后
```

## 介绍 {#rootfinding-intro}


## 牛顿法

牛顿法（Newton Method，or Newton-Raphson method）是最常用且高效的求根算法之一。假设函数 $f(x)$ 可导并一阶导 $f^{\prime}(x)$ 连续，且 $x^*$ 为 $f(x) = 0$ 的根。设 $x_0$ 是对 $x^*$ 的一个好的估计，令 $x^* = x_0 + h$。因为 $x^*$ 是$f(x) = 0$的根而且 $h = x^* - x_0$，所以 $h$ 描述了 $x_0$距离真实根的距离。

因为 $h$ 很小，我们通过线性逼近可以得到：

$$0 = f(x^*) = f(x_0+h) \approx f(x_0) + h f^{\prime}(x_0),$$

所以除非 $f^{\prime}(x_0)$ 接近于0，我们得到：

$$h \approx-\frac{f\left(x_{0}\right)}{f^{\prime}\left(x_{0}\right)}.$$

从而，

$$x^*=x_{0}+h \approx x_{0}-\frac{f\left(x_{0}\right)}{f^{\prime}\left(x_{0}\right)},$$

我们可以把这个新的估计 $x_1$ 做为对 $x^*$ 更好的估计：

$$x_{1}=x_{0}-\frac{f\left(x_{0}\right)}{f^{\prime}\left(x_{0}\right)}.$$

如果我们继续更新，就可以得到 $x_2$：

$$x_{2}=x_{1}-\frac{f\left(x_{1}\right)}{f^{\prime}\left(x_{1}\right)}.$$

按照这种思路继续迭代下去，就是牛顿法求根。牛顿法更一般的写法如下。

\centering
```{block, type='method'}
**牛顿法**

1. 选择初始猜测点 $x_0$，设置 $n = 0$。
2. 按照以下迭代过程进行迭代：
\begin{equation}
x_{n+1}=x_{n}-\frac{f\left(x_{n}\right)}{f^{\prime}\left(x_{n}\right)}.
\end{equation}
3. 计算 $|f(x_{n+1})|$。
    1. 如果 $|f(x_{n+1})| \leq \epsilon$，停止迭代；
    2. 否则，返回第 2 步
    
```

下面我们来看一下牛顿法更直观的解释。

```{r, child=ifelse(knitr::is_html_output(), "02-rootfinding-newton-gif.Rmd", "02-rootfinding-newton-pdf.Rmd")}
```




现在我们将牛顿法在 R 中实现，以下 `newton.root()` 函数中的第一个参数为待求根的函数 $f(x)$，因为牛顿法中每一次迭代都需要求 $f(x)$ 和 $f^{\prime}(x)$ 在 $x_n$ 处的取值，因此我们定义了 R 函数 `ftn()` ，它的输入参数为 $f(x)$ 的表达式及 $x$ 的取值，输出为  $f(x)$ 和 $f^{\prime}(x)$。具体代码如下。

```{r newton-root}
newton.root <- function(f, x0 = 0, tol = 1e-9, max.iter = 100) {
  x <- x0
  cat(paste0("初始值：x = ", x, "\n"))
  fx <- ftn(f, x)
  iter <-  0
  # xs用来保存每步迭代得到的x值
  xs <- list() 
  xs[[iter + 1]] <- x
  # 继续迭代直到满足停止条件
  while ((abs(fx$f) > tol) && (iter < max.iter)) {
    x <- x - fx$f/fx$fgrad
    fx <- ftn(f, x)
    iter <-  iter + 1
    xs[[iter + 1]] <- x
    cat(paste0("迭代第", iter, "次：x = ", x, "\n"))
  }
  
  # output depends on success of algorithm
  if (abs(fx$f) > tol) {
    cat("算法无法收敛\n")
    return(NULL)
  } else {
    cat("算法收敛\n")
    return(xs)
  }
}

ftn <- function(f, x){
  df <- deriv(f, 'x', func = TRUE)
  dfx <- df(x)
  f <- dfx[1]
  fgrad <- attr(dfx, 'gradient')[1,]
  return(list(f = f, fgrad = fgrad))
}
```


```{example}
求 $f(x) = x^2 - 5$ 的根。

```{r}
f <- expression(x^2 - 5)
roots <- unlist(newton.root(f, 5))
```
```{r, echo=FALSE}
# plot
library(ggplot2)
cggplot(data.frame(x=c(-5, 5)), aes(x)) + 
  stat_function(fun=function(x) x^2 - 5) + 
  ylab(expression(f(x))) +
  geom_hline(yintercept = 0, color = 'lightgrey') +
  geom_vline(xintercept = roots, linetype = 'longdash', color = 'red') +
  annotate(geom="text", x= roots[1:3] + 0.15, y=-0.5, label=c(expression(x[0]), expression(x[1]), expression(x[2])), color="red") + annotate(geom="text", x= roots[4] - 0.15, y=-0.5, label=c(expression(x[3])), color="red") +
  geom_point(data = data.frame(x = roots, y = 0), aes(x = x, y = y), color = 'red', size = 2) + 
  ggtitle(parse(text = paste0('"牛顿法求根： "', ' ~ f(x) == ~ x^2 - 5')))
```

```